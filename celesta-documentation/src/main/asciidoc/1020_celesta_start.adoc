= Операции, выполняемые при инициализации Celesta
:lang: ru
:is-main-doc:
include::_doc_general_attributes.adoc[]
:toclevels: 3
:doctype: book
:img: images
:lupa: icon:search[]
:source-highlighter: highlightjs
:toc: left

//image::{img}/
//tag::celesta_start[]

== Общая последовательность операций

Инициализация Celesta происходит в несколько этапов, о чём сообщает вывод в `stdout`:

```
Celesta initialization: score parsing...done.
Celesta pre-initialization: system settings reading...done.
Celesta initialization: database upgrade...done.
```

1. В процессе *чтения системных настроек* Celesta анализирует состояние <<basic_settings_section,базовой настройки>>, проверяет тот факт, что все обязательные параметры заданы, и что все параметры заданы корректно. При обнаружении ошибки в настройках запуск системы не будет продолжен.

2. При *разборе метаданных* происходит чтение всех файлов *.sql в алфавитном порядке, их синтаксический анализ и построение внутренней объектной модели базы данных (метаданных). Система в папках `score` собирает из скриптов CelestaSQL информацию о гранулах, таблицах и полях. Вычисляются их контрольные суммы, находятся версии. При возникновении ошибок синтаксиса или несогласованности CelestaSQL-скриптов на данном этапе запуск системы прерывается.

3. Процедура *авто-миграции* базы данных является наиболее сложной и затратной по времени.

== Автоматическая миграция базы данных

На этом этапе сервер приложений соединяется с базой данных и проверяет наличие в ней системной таблицы celesta.grains. Если таблица не найдена, она автоматически создаётся (CREATE-командой), однако это происходит лишь в следующих случаях: 1) база данных совершенно пустая 2) в базовой настройке выставлено свойство force.dbinitialize (это защищает от «порчи» существующих, непустых баз данных при ошибочном присоединении к ним системы Celesta). Если в процессе проверки наличия/создания таблицы celesta.grains возникла ошибка, то генерируется фатальная ошибка и система не запускается.

=== Определение необходимости миграции гранулы (схемы)

Далее идёт цикл по всем доступным в метаданных гранулам (схемам) и всем доступным в celesta.grains гранулам. (При этом из процесса миграции исключаются гранулы, объявленные с опцией WITH NO AUTOUPDATE в CelestaSQL-скрипте). 

. Если гранула есть в метаданных, но её нет в celesta.grains — выполняется апдейт по creation-скрипту (т. е. предполагается, что соответствующие таблицы в базе данных могут и присутствовать).

. Если гранула есть в celesta.grains, но её нет в метаданных — ничего не происходит. Автоматически гранулы из базы данных не удаляются, т. к. их таблицы могут содержать важную информацию. Просто для этих таблиц не будут сформированы классы доступа к данным.

. Если гранула есть и там, и там: сервер приложений находит в таблице celesta.grains запись про состояние, версию и контрольную сумму метаданных, которые «накатаны» на базу данных при последнем запуске и сравнивает с версией метаданных, которыми сервер располагает.

** *recover (3)* — действуем аналогично отсутствию записи.

** *lock (4)* — структура не обновляется, переходим к следующей грануле.

** *upgrading (1)* — останов процесса с ошибкой  “Cannot proceed with database upgrade: there are grains not in 'ready', 'recover' or 'lock' state”.

** *error (2)* — останов процесса с ошибкой “Cannot proceed with database upgrade: there are grains not in 'ready', 'recover' or 'lock' state”.

** *ready (0)* — продолжение процесса.

... Если версия и контрольная сумма совпадают — ничего не происходит.

... Если версия различна: если версия изменилась в сторону увеличения — апгрейд вне зависимости от контрольной суммы. Если в сторону уменьшения либо если версия несовместима (см. выше <<version_tags,описание логики работы>> с version tags) — вне зависимости от контрольной суммы останов с ошибкой: “Grain '...' version '...' is lower than / is inconsistent with database grain version '...'. Will not proceed with auto-upgrade.”

... Если версия совпадает, а контрольная сумма различна – апгрейд.

=== Процедура миграции гранулы (схемы). 

Если на основании описанного выше алгоритма система решает, что апгрейд гранулы необходим — в грануле сбрасываются все представления и начинается цикл по таблицам в метаданных. Если таблица не найдена в базе, она создаётся. Если таблица найдена — цикл по полям. Если поле не найдено, оно создаётся (следует учесть, что добавление в непустую таблицу not null поля без значения default приводит к ошибке). Если поле найдено, и в нём не совпадает тип, default-значение или ограничение null/not null — конвертируется тип или соответствующие атрибуты поля — опять же, это возможно не всегда, в зависимости от имеющихся в таблице данных. Ошибки на данном этапе приводят к переводу гранулы в состояние *error* и требуют ручного вмешательства администратора базы данных. После завершения синхронизации таблиц синхронизируются внешние ключи на таблицах, и полностью синхронизируются индексы на таблицах гранулы, чтобы состав индексов в БД соответствовал составу индексов, объявленных в creation-скрипте. В самую последнюю очередь создаются представления (views).

При процедуре апгрейда не происходит удаления полей из базы данных, удаления таблиц и тем более удаления целых гранул. Если администратор базы данных уверен, что соответствующие объекты (и содержащиеся в них данные!) более не нужны, он должен проделать удаление вручную.

Тем не менее, при синхронизации будет происходить удаление внешних ключей, индексов и представлений, если их объявления были убраны из скрипта создания гранулы.

== Полное или частичное отключение автоматической миграции

В Celesta имеется несколько способов отключить процесс автообновления:

* *на уровне всей базы данных* — с помощью опции skip.dbupdate в <<basic_settings_section,настроечном .properties-файле>>,

* *на уровне схемы* — выставив её статус в <<celesta_grains_table,таблице celesta.grains>> в 4 либо объявив опцию `WITH NO AUTOUPDATE` в <<create_schema_statement,выражении создания гранулы>> (схемы),

* *на уровне таблицы* — объявив <<celestasql_with_options,опцию `WITH NO AUTOUPDATE`>> в выражении создания таблицы.

//end::celesta_start[]

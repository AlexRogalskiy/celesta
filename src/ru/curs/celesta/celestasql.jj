options{
    IGNORE_CASE=true ;
    STATIC=false;
//  DEBUG_LOOKAHEAD= true ;
    FORCE_LA_CHECK=true;
//  DEBUG_TOKEN_MANAGER=true;
}

PARSER_BEGIN(CelestaParser)
package ru.curs.celesta;
public class CelestaParser{
}
PARSER_END(CelestaParser)

SKIP:
{
    " "
|   "\t"
|   "\r"
|   "\n"
}

TOKEN: /* SQL Keywords. prefixed with K_ to avoid name clashes */ 
{
    <K_CREATE:  "CREATE">
|   <K_TABLE:   "TABLE">
|   <K_DEFAULT: "DEFAULT">
|   <K_NOT:     "NOT">
|   <K_NULL:   "NULL">
|   <K_MAX:    "MAX">
|   <K_IDENTITY: "IDENTITY">
|   <K_GETDATE: "GETDATE">
|   <K_PRIMARY: "PRIMARY">
|   <K_FOREIGN: "FOREIGN">
|   <K_KEY:    "KEY">
|   <K_REFERENCES: "REFERENCES">
|   <K_ON:      "ON">
|   <K_UPDATE:  "UPDATE">
|   <K_DELETE:  "DELETE">
|   <K_NO:     "NO">
|   <K_ACTION:  "ACTION">
|   <K_SET:     "SET">
|   <K_CASCADE:  "CASCADE">
}

TOKEN: /* Datatypes */
{
   <K_INT:     "INT">
|   <K_REAL:     "REAL">
|  <K_NVARCHAR:     "NVARCHAR">
|  <K_IMAGE:     "IMAGE">
|  <K_DATETIME:     "DATETIME">
|  <K_BIT:     "BIT">
}

TOKEN : /* Numeric Constants */
{
	< S_DOUBLE: ((<S_INTEGER>)? "." <S_INTEGER> ( ["e","E"] ([ "-","+"])? <S_INTEGER> )? 
				|
				(<S_INTEGER>)+ (".")? ["e","E"] ([ "-","+"])? (<S_INTEGER>)+
				)>
  | 	< S_INTEGER: ( <DIGIT> )+ >
  | 	< #DIGIT: ["0" - "9"] >
  |     <S_BINARY_LITERAL: "0x"(["a"-"f", "A"-"F", "0"-"9"]["a"-"f", "A"-"F", "0"-"9"])+>
}


TOKEN:
{
	< S_IDENTIFIER: ( <LETTER> )+ ( <DIGIT> | <LETTER> |<SPECIAL_CHARS>)* >
| 	< #LETTER: ["a"-"z", "A"-"Z", "_"] >
|   < #SPECIAL_CHARS: "$" | "_">
|   < S_CHAR_LITERAL: "'" (~["'"])* "'" ("'" (~["'"])* "'")*>
|   < S_QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" | ("`" (~["\n","\r","`"])* "`") >
}


SPECIAL_TOKEN:
{
   <LINE_COMMENT: "--"(~["\r","\n"])*>
|  <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">

}

/*Метамодель состоит из описания таблиц*/
GrainModel model():
{
   /*This work is dedicated to Maria, my misterious muse :-) 
     Ivan Ponomarev, June 2013.*/
	 
   GrainModel m = new GrainModel();
}
{ 
   ( createTable(m) ";")*
   {
   return m;
   }
}



void createTable(GrainModel m):
{
	Table table = null;
	Token tableName = null;
}
{
	<K_CREATE> <K_TABLE>
	tableName = <S_IDENTIFIER> {table = new Table(m, tableName.toString());}
	"("
		tableConstituent(table)	("," tableConstituent(table))*
	")"
	{
	  table.finalizePK();
      m.addTable(table);
    }
}

void tableConstituent(Table table):{}
{
     columnDefinition(table) 
   | primaryKey(table)
   | foreignKey(table)
}

void columnDefinition(Table table):
{
   Column column = null;
   Token token;
   Token length = null;
   boolean nullable;
   boolean negative = false;
   boolean pk = false;
   ForeignKey fk = null;
}
{
  token = <S_IDENTIFIER>
    (  (<K_INT>       {column = new IntegerColumn(token.toString()); token = null; } 
	       nullable = nullable() 
		  [(<K_DEFAULT> ["-"] {negative = true;} token = <S_INTEGER>)
		  |(token = <K_IDENTITY>) 
		  ])
    |  (<K_REAL>      {column = new FloatingColumn(token.toString()); token = null;} 
	       nullable = nullable() 
		  [<K_DEFAULT> ["-"] {negative = true;} (token = <S_INTEGER> | token = <S_DOUBLE>)])
    |  (<K_NVARCHAR> {column = new StringColumn(token.toString()); token = null; } 
	          ["("  (length = <S_INTEGER> | length = <K_MAX>) ")"]  
			  {((StringColumn) column).setLength(length.toString());}
	       nullable = nullable() 
		  [<K_DEFAULT> token = <S_CHAR_LITERAL>])
    |  (<K_IMAGE>     {column = new BinaryColumn(token.toString()); token = null;} 
	       nullable = nullable()
		  [<K_DEFAULT> token = <S_BINARY_LITERAL>])
    |  (<K_DATETIME>  {column = new DateTimeColumn(token.toString()); token = null;} 
	       nullable = nullable()
		  [<K_DEFAULT> (token = <S_CHAR_LITERAL> | token = <K_GETDATE> "(" ")")])
    |  (<K_BIT>       {column = new BooleanColumn(token.toString()); token = null;}) 
	       nullable = nullable() 
	      [<K_DEFAULT> token = <S_CHAR_LITERAL>])
	[<K_PRIMARY> <K_KEY> {pk = true;}]
	{ 
      column.setNullableAndDefault(nullable, token == null? null: ((negative? "-": "") + token.toString()));
	  table.addColumn(column);
	  if (pk) {
	    table.addPK(column.getName());
	    table.finalizePK();
	  }
    }
	[<K_FOREIGN> <K_KEY> {fk = new ForeignKey(table); fk.addColumn(column.getName());} references(fk)]
}

boolean nullable():
{
  boolean result = true;
}
{
[<K_NULL>         {result = true;} |<K_NOT> <K_NULL> {result = false;}] { return result;}
}

void primaryKey(Table table):{Token token;}
{
  <K_PRIMARY> <K_KEY> "(" token = <S_IDENTIFIER> {table.addPK(token.toString());}
                     ("," token = <S_IDENTIFIER> {table.addPK(token.toString());})* ")"
  {
    table.finalizePK();
  }
}

void foreignKey(Table table):{
  Token token;
}
{
<K_FOREIGN><K_KEY> { ForeignKey fk = new ForeignKey(table);}
   "(" token = <S_IDENTIFIER> {fk.addColumn(token.toString());}
  ("," token = <S_IDENTIFIER> {fk.addColumn(token.toString());})* ")"

  references(fk) 
}

void references(ForeignKey fk):{
  Token token;
  FKBehaviour action;
}
{
<K_REFERENCES> token = <S_IDENTIFIER> 
  {fk.setReferencedTable("", token.toString());} 
  "(" <S_IDENTIFIER> ("," <S_IDENTIFIER> )* ")"

[<K_ON>
  ((<K_UPDATE> action = action() {fk.setUpdateBehaviour(action);} 
    [<K_ON> <K_DELETE> action = action() {fk.setDeleteBehaviour(action);}])
  |(<K_DELETE> action = action() {fk.setDeleteBehaviour(action);} 
    [<K_ON> <K_UPDATE> action = action() {fk.setUpdateBehaviour(action);}]))
]
}

FKBehaviour action():{
  FKBehaviour result;
}
{
   ((<K_NO> <K_ACTION> {result = FKBehaviour.NO_ACTION;})
  |(<K_SET> <K_NULL>  {result =  FKBehaviour.SETNULL;})
  | (<K_CASCADE>        {result =  FKBehaviour.CASCADE;}))
  {
    return result;
  }
}
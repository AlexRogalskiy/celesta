options{
    IGNORE_CASE=true ;
	UNICODE_INPUT=true;
    STATIC=false;
//  DEBUG_LOOKAHEAD= true ;
    FORCE_LA_CHECK=true;
//  DEBUG_TOKEN_MANAGER=true;
}

PARSER_BEGIN(CelestaParser)
package ru.curs.celesta.score;
//CHECKSTYLE:OFF
public class CelestaParser{
}
PARSER_END(CelestaParser)

SKIP:
{
    " "
|   "\t"
|   "\r"
|   "\n"
}

TOKEN: /* SQL keywords */ 
{
    <K_CREATE:  "CREATE">
|   <K_TABLE:   "TABLE">
|   <K_INDEX:   "INDEX">
|   <K_VIEW:    "VIEW">
|   <K_AS:      "AS">
|   <K_DEFAULT: "DEFAULT">
|   <K_NOT:     "NOT">
|   <K_NULL:    "NULL">
|   <K_MAX:     "MAX">
|   <K_IDENTITY: "IDENTITY">
|   <K_GETDATE: "GETDATE">
|   <K_PRIMARY: "PRIMARY">
|   <K_FOREIGN: "FOREIGN">
|   <K_KEY:     "KEY">
|   <K_REFERENCES: "REFERENCES">
|   <K_ON:       "ON">
|   <K_UPDATE:   "UPDATE">
|   <K_DELETE:   "DELETE">
|   <K_NO:       "NO">
|   <K_ACTION:   "ACTION">
|   <K_SET:      "SET">
|   <K_CASCADE:  "CASCADE">
|   <K_ALTER:    "ALTER">
|   <K_ADD:      "ADD">
|   <K_CONSTRAINT:"CONSTRAINT">
|   <K_IN:       "IN">
|   <K_OR:       "OR">
|   <K_AND:      "AND">
|   <K_LIKE:     "LIKE">
|   <K_BETWEEN:  "BETWEEN">
|   <K_IS:       "IS">
|   <K_SELECT:   "SELECT">
|   <K_DISTINCT: "DISTINCT">
|   <K_FROM:     "FROM">
|   <K_INNER:    "INNER">
|   <K_LEFT:     "LEFT">
|   <K_RIGHT:    "RIGHT">
|   <K_FULL:     "FULL">
|   <K_JOIN:     "JOIN">
|   <K_WHERE:    "WHERE">
}

TOKEN: /* Datatypes */
{
   <K_INT:       "INT">
|  <K_REAL:      "REAL">
|  <K_NVARCHAR:  "NVARCHAR">
|  <K_IMAGE:     "IMAGE">
|  <K_DATETIME:  "DATETIME">
|  <K_BIT:       "BIT">
}

TOKEN : /* Numeric literals */
{
	< S_DOUBLE: ((<S_INTEGER>)? "." <S_INTEGER> ( ["e","E"] ([ "-","+"])? <S_INTEGER> )? 
				|
				(<S_INTEGER>)+ (".")? ["e","E"] ([ "-","+"])? (<S_INTEGER>)+
				)>
  | 	< S_INTEGER: ( <DIGIT> )+ >
  | 	< #DIGIT: ["0" - "9"] >
  |     <S_BINARY_LITERAL: "0x"(["a"-"f", "A"-"F", "0"-"9"]["a"-"f", "A"-"F", "0"-"9"])+>
}


TOKEN:
{
	< S_IDENTIFIER: ( <LETTER> )+ ( <DIGIT> | <LETTER> )* >
| 	< #LETTER: ["a"-"z", "A"-"Z", "_"] >
|   < S_CHAR_LITERAL: "'" (~["'"])* "'" ("'" (~["'"])* "'")*>
|   < S_QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" | ("`" (~["\n","\r","`"])* "`") >
|   < CELESTA_DOC: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}


SPECIAL_TOKEN:
{
   <LINE_COMMENT: "--"(~["\r","\n"])*>
|  <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

/*Metamodel. Root rule.*/
Grain grain(Score s, String name):
{
   /*This work is dedicated to Maria, my misterious muse :-) 
     Ivan Ponomarev, June 2013.*/
	 
   Grain g = new Grain(s, name);
   Token t;
   Token doc = null;
}
{ 
   [doc = <CELESTA_DOC> {g.setCelestaDocLexem(doc.toString());}]
   <K_CREATE> 
   t = <S_IDENTIFIER> {if (!"GRAIN".equalsIgnoreCase(t.toString())) 
      throw new ParseException(String.format(
	  "Error: expected 'create GRAIN' at the beginning of the grain '%s' definition.", name));}
   t = <S_IDENTIFIER> {if (!name.equalsIgnoreCase(t.toString())) throw new ParseException(String.format(
      "Error: expected 'create grain %s' at the beginning of the grain '%s' definition, found '%s'.", name, name, t.toString()));}
   t = <S_IDENTIFIER> {if (!"VERSION".equalsIgnoreCase(t.toString())) throw new ParseException(String.format(
      "Error: expected 'create grain %s VERSION' at the beginning of the grain '%s' definition.", name, name));}
   t = <S_CHAR_LITERAL> {g.setVersion(t.toString());}";"
   ( ( ([doc = <CELESTA_DOC>]<K_CREATE> (
                    createTable(g, doc == null? null: doc.toString()) 
                  | createIndex(g, doc == null? null: doc.toString())
				  | createView (g, doc == null? null: doc.toString())) {doc = null;}) 
	 | (<K_ALTER>   alterTable(g))) ";")*
   <EOF>
   {
   g.completeParsing();
   return g;
   }
}

void createTable(Grain g, String doc):
{
	Table table = null;
	Token tableName = null;
}
{
    <K_TABLE>
	tableName = <S_IDENTIFIER> {table = new Table(g, tableName.toString());
	                            table.setCelestaDocLexem(doc);}
	"("
		tableConstituent(table)	("," tableConstituent(table))*
	")"
	{
	  table.finalizePK();
    }
}

void tableConstituent(Table table):{
  String name; 
  ForeignKey fk;
}
{
     columnDefinition(table) 
   | name = constraint(table.getGrain()) (
          primaryKey(table) {table.setPkConstraintName(name);}
        | fk = foreignKey(table) {fk.setConstraintName(name);})
}

void columnDefinition(Table table):
{
   Column column = null;
   Token t;
   Token length = null;
   boolean nullable;
   boolean negative = false;
   boolean pk = false;
   ForeignKey fk = null;
   String name;
   Token doc = null;
}
{
 [doc = <CELESTA_DOC>]
  t = <S_IDENTIFIER>
    (  (<K_INT>       {column = new IntegerColumn(table, t.toString()); t = null; } 
	       nullable = nullable() [(<K_DEFAULT> ["-" {negative = true;}] t = <S_INTEGER>)|(t = <K_IDENTITY> [<K_NOT> <K_NULL> {nullable = false;}])]
	    )
    |  (<K_REAL>      {column = new FloatingColumn(table, t.toString()); t = null;} 
	       nullable = nullable() 
		  [<K_DEFAULT> ["-" {negative = true;}] (t = <S_INTEGER> | t = <S_DOUBLE>)])
    |  (<K_NVARCHAR> {column = new StringColumn(table, t.toString()); t = null; } 
	          ["("  (length = <S_INTEGER> | length = <K_MAX>) ")"]  
			  {((StringColumn) column).setLength(length.toString());}
	       nullable = nullable() 
		  [<K_DEFAULT> t = <S_CHAR_LITERAL>])
    |  (<K_IMAGE>     {column = new BinaryColumn(table, t.toString()); t = null;} 
	       nullable = nullable()
		  [<K_DEFAULT> t = <S_BINARY_LITERAL>])
    |  (<K_DATETIME>  {column = new DateTimeColumn(table, t.toString()); t = null;} 
	       nullable = nullable()
		  [<K_DEFAULT> (t = <S_CHAR_LITERAL> | t = <K_GETDATE> "(" ")")])
    |  (<K_BIT>       {column = new BooleanColumn(table, t.toString()); t = null;}) 
	       nullable = nullable() 
	      [<K_DEFAULT> (t = <S_CHAR_LITERAL>| t = <S_INTEGER>)])
	name = constraint(table.getGrain()) [<K_PRIMARY> <K_KEY> 
	      {pk = true; table.setPkConstraintName(name);} name = constraint(table.getGrain())]
	{ 
      column.setNullableAndDefault(nullable, t == null? null: ((negative? "-": "") + t.toString()));
	  column.setCelestaDocLexem(doc == null? null:doc.toString());
	  if (pk) {
	    table.addPK(column.getName());
	    table.finalizePK();
	  }
    }
	[<K_FOREIGN> <K_KEY> {fk = new ForeignKey(table); fk.addColumn(column.getName()); fk.setConstraintName(name);} references(fk)]
}

boolean nullable():
{
  boolean result = true;
}
{
[<K_NULL>         {result = true;} |<K_NOT> <K_NULL> {result = false;}] { return result;}
}

void primaryKey(Table table):{Token t;}
{
  <K_PRIMARY> <K_KEY> "(" t = <S_IDENTIFIER> {table.addPK(t.toString());}
                     ("," t = <S_IDENTIFIER> {table.addPK(t.toString());})* ")"
  {
    table.finalizePK();
  }
}

ForeignKey foreignKey(Table table):{
  Token t;
  ForeignKey fk;
}
{
<K_FOREIGN><K_KEY> { fk = new ForeignKey(table);}
   "(" t = <S_IDENTIFIER> {fk.addColumn(t.toString());}
  ("," t = <S_IDENTIFIER> {fk.addColumn(t.toString());})* ")"

  references(fk) {
  return fk;
  }
}

void references(ForeignKey fk):{
  Token t;
  Token t2 = null;
  FKRule action;
}
{
<K_REFERENCES> t = <S_IDENTIFIER> ["." t2 = <S_IDENTIFIER>]
  { if (t2 == null)
      fk.setReferencedTable("", t.toString());
	else 
	  fk.setReferencedTable(t.toString(), t2.toString());}
	  
  "(" t = <S_IDENTIFIER> {fk.addReferencedColumn(t.toString());}
  ("," t = <S_IDENTIFIER> {fk.addReferencedColumn(t.toString());})* ")"
{fk.finalizeReference();}
[<K_ON>
  ((<K_UPDATE> action = action() {fk.setUpdateRule(action);} 
    [<K_ON> <K_DELETE> action = action() {fk.setDeleteRule(action);}])
  |(<K_DELETE> action = action() {fk.setDeleteRule(action);} 
    [<K_ON> <K_UPDATE> action = action() {fk.setUpdateRule(action);}]))
]
}

FKRule action():{
  FKRule result;
}
{
   ((<K_NO> <K_ACTION> {result = FKRule.NO_ACTION;})
  |(<K_SET> <K_NULL>  {result =  FKRule.SET_NULL;})
  | (<K_CASCADE>        {result =  FKRule.CASCADE;}))
  {
    return result;
  }
}

void createIndex(Grain g, String doc):{
Token indexName;
Token tableName;
Token columnName;
Index ind;
}
{
<K_INDEX> indexName = <S_IDENTIFIER> <K_ON> tableName = <S_IDENTIFIER> 
   {ind = new Index(g, tableName.toString(), indexName.toString());
    ind.setCelestaDocLexem(doc);}
   "(" columnName = <S_IDENTIFIER> {ind.addColumn(columnName.toString());} ("," columnName = <S_IDENTIFIER>{ind.addColumn(columnName.toString());}) * ")"
   {ind.finalizeIndex();}
}

void alterTable(Grain g):{
  Token t;
  Table table;
  String name;
  ForeignKey fk;
}
{
<K_TABLE> t = <S_IDENTIFIER> {
  table = g.getTable(t.toString());
  }
<K_ADD> name = constraint(g) fk = foreignKey(table) {fk.setConstraintName(name);}
}

String constraint(Grain g):{
Token t = null;
}
{
[<K_CONSTRAINT> t = <S_IDENTIFIER>]
{
if (t == null)
  return null;
else {
  g.addConstraintName(t.toString());
  return t.toString();
} 
}
}

void createView(Grain g, String doc):
{
	View view = null;
	Token viewName = null;
}
{
<K_VIEW> viewName = <S_IDENTIFIER> <K_AS> {view = new View(g, viewName.toString());
	                            view.setCelestaDocLexem(doc);}
								select()
}

void sqlExpression():
{}
{
    sqlAndExpression() (<K_OR> sqlAndExpression())*
}

void sqlAndExpression():
{}
{
    sqlUnaryLogicalExpression() (<K_AND> sqlUnaryLogicalExpression())*
}

void sqlUnaryLogicalExpression():
{}
{
  [<K_NOT>] sqlRelationalExpression()
}

void sqlRelationalExpression():
{}
{
    sqlSimpleExpression()
    ( relop() sqlSimpleExpression()
      | (<K_IN> "(" sqlExpression() ("," sqlExpression())* ")")
      | (<K_BETWEEN> sqlSimpleExpression() <K_AND> sqlSimpleExpression())
      | (<K_LIKE> sqlSimpleExpression())
      | (<K_IS> <K_NULL>)
   )?
}

void relop():
{}
{
    "="
  | ">" ["="]
  | "<" ["=" | ">" ]
}


void sqlSimpleExpression():
{}
{
    sqlMultiplicativeExpression() ( ("+" | "-" )
                                 sqlMultiplicativeExpression()
                               )*
}

void sqlMultiplicativeExpression():
{}
{
    sqlUnaryExpression() (  ("*" | "/" ) sqlUnaryExpression())*
}

void sqlUnaryExpression():
{}
{
    (("+" | "-") sqlPrimaryExpression())
|
    sqlPrimaryExpression()
}


void sqlPrimaryExpression():
{}
{
    <S_INTEGER>
  | <S_DOUBLE>
  | <S_CHAR_LITERAL>
  | <K_NULL>
  | "(" sqlExpression() ")"
  | fieldReference()
}

void fieldReference():
{}
{
  <S_IDENTIFIER> ["." <S_IDENTIFIER> ["." <S_IDENTIFIER>]]
}

void select():
{}
{
    <K_SELECT> [ <K_DISTINCT> ] selectItem() ("," selectItem())*
    <K_FROM>  fromClause()
    [<K_WHERE> sqlExpression() ]
}

void selectItem():
{}
{
   fieldReference() [<K_AS>] [<S_IDENTIFIER>] //alias
}

void tableReference():
{}
{
  <S_IDENTIFIER>["." <S_IDENTIFIER>] [<K_AS>] [<S_IDENTIFIER>]
}

void fromClause():
{}
{
    tableReference() 
    (join())*
}

void join():
{}
{
  (<K_INNER> | <K_LEFT> | <K_RIGHT> | <K_FULL>) 
  <K_JOIN>
   tableReference()
   <K_ON> 
   sqlExpression()
}
